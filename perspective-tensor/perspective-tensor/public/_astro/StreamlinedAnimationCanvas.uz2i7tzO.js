import{r as q}from"./index.RH_Wq4ov.js";var k={exports:{}},z={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var W;function N(){if(W)return z;W=1;var e=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function s(a,n,o){var h=null;if(o!==void 0&&(h=""+o),n.key!==void 0&&(h=""+n.key),"key"in n){o={};for(var i in n)i!=="key"&&(o[i]=n[i])}else o=n;return n=o.ref,{$$typeof:e,type:a,key:h,ref:n!==void 0?n:null,props:o}}return z.Fragment=t,z.jsx=s,z.jsxs=s,z}var _;function V(){return _||(_=1,k.exports=N()),k.exports}var $=V();function C(e,t,s){return e+(t-e)*s}function D(e,t,s){return[C(e[0],t[0],s),C(e[1],t[1],s),C(e[2],t[2],s)]}function J(e,t){e.width=Math.floor(t.width*t.dpr),e.height=Math.floor(t.height*t.dpr),e.style.width=t.width+"px",e.style.height=t.height+"px";const s=e.getContext("2d");return s.setTransform(t.dpr,0,0,t.dpr,0,0),s}function U(e){return{x:new Array(e).fill(0),y:new Array(e).fill(0),z:new Array(e).fill(0)}}function Z(e,t){const s=t.speed*t.amplitude,a=t.damping;for(let n=0;n<e.x.length;n++)e.x[n]=e.x[n]*a+(Math.random()-.5)*s,e.y[n]=e.y[n]*a+(Math.random()-.5)*s,e.z[n]=e.z[n]*a+(Math.random()-.5)*s}function Q(){return document.documentElement.classList.contains("dark")}function K(){const e=Q();return{nodeColor:e?"rgba(226, 232, 240, 0.6)":"rgba(30, 41, 59, 0.5)",lineColor:e?"rgb(203, 213, 225)":"rgb(30, 41, 59)",isDark:e}}function tt(e,t=0){let s=0,a=0;for(let p=0;p<e.length;p++)s+=e[p][0],a+=e[p][1];const n=s/Math.max(1,e.length)-t,o=a/Math.max(1,e.length),h=new Array(e.length);let i=1/0,r=-1/0,c=1/0,M=-1/0;for(let p=0;p<e.length;p++){const y=e[p][0]-n,b=e[p][1]-o,R=e[p][2];h[p]=[y,b,R],y<i&&(i=y),y>r&&(r=y),b<c&&(c=b),b>M&&(M=b)}return{centered:h,bounds:{minX:i,maxX:r,minY:c,maxY:M}}}function st(e,t=1){return new Array(e).fill(t)}const x=729,H={targetSize:20,rot:{x:-.3,y:.4}},nt=e=>{const[t,s,a,n]=[H.rot.x,H.rot.y].flatMap(r=>[Math.cos(r),Math.sin(r)]),o=e.map(([r,c,M])=>[r*a-M*n,c*t-(r*n+M*a)*s,c*s+(r*n+M*a)*t]),h=o.reduce((r,c)=>({min:c.map((M,p)=>Math.min(r.min[p],M)),max:c.map((M,p)=>Math.max(r.max[p],M))}),{min:[1/0,1/0,1/0],max:[-1/0,-1/0,-1/0]}),i=H.targetSize/Math.max(...h.max.map((r,c)=>r-h.min[c]));return o.map(r=>r.map(c=>c*i))},I=(e,t)=>{const s=nt(e),{centered:a,bounds:n}=tt(s);return{positions:a,edges:t,lineBrightness:st(t.length,.8),bounds:n}},T=e=>()=>(Math.random()-.5)*e,et=()=>{const e=T(.15),t=Array.from({length:x},(a,n)=>[81,9,1].map(o=>2.5*(~~(n/o)%9-4)+e())),s=t.flatMap((a,n)=>[81,9,1].filter(o=>n%o+o<x&&~~(n/o)%9<8).map(o=>[n,n+o]));return I(t,s)},ot=()=>{const e=(1+Math.sqrt(5))/2,t=7,s=T(.3),a=[],n=[],o=Math.floor(x/t);for(let i=0;i<t;i++){const r=i===t-1?x-a.length:o,c=a.length,M=Math.random()*2*Math.PI,p=Math.acos(2*Math.random()-1),y=6+Math.random()*4,b=[y*Math.sin(p)*Math.cos(M),y*Math.sin(p)*Math.sin(M),y*Math.cos(p)],R=[];for(let u=0;u<r;u++){const g=u/(r-1),w=Math.acos(1-2*g),A=2*Math.PI*u*e,E=3*(.5+.5*Math.random()),S=[b[0]+E*Math.sin(w)*Math.cos(A)+s(),b[1]+E*Math.cos(w)+s(),b[2]+E*Math.sin(w)*Math.sin(A)+s()];a.push(S),R.push(S)}const l=R.reduce((u,g)=>[u[0]+g[0],u[1]+g[1],u[2]+g[2]],[0,0,0]),f=[l[0]/r,l[1]/r,l[2]/r];let m=1/0,d=c;for(let u=0;u<R.length;u++){const g=R[u],w=Math.sqrt((g[0]-f[0])**2+(g[1]-f[1])**2+(g[2]-f[2])**2);w<m&&(m=w,d=c+u)}n.push(d)}const h=[];for(let i=0;i<t;i++){const r=n[i],c=i*o,M=i===t-1?x-c:o;for(let p=0;p<M;p++)c+p!==r&&h.push([r,c+p]);h.push([r,n[(i+1)%t]])}return I(a,h)},it=e=>{const t=8+Math.random()*8,s=.3+Math.random()*.5;return Array.from({length:x},(a,n)=>{const o=n/x,h=t*Math.PI*o,i=12*Math.pow(o,s),r=.3*(1-o)*Math.cos(h);return[i*Math.cos(h)+e(),i*Math.sin(h)+e(),r+e()]})},at=e=>{const s=Math.floor(x/27);return Array.from({length:x},(a,n)=>{const o=n%27,i=Math.floor(n/27)/s*2*Math.PI,r=(o/26-.5)*2,c=10,M=c*Math.cos(i),p=c*Math.sin(i),y=2*Math.sin(3*i),b=i/2,R=3.5,l=-Math.cos(i),f=-Math.sin(i),m=1,d=l*Math.cos(b),u=f*Math.cos(b),g=m*Math.sin(b);return[M+r*R*d+e(),p+r*R*u+e(),y+r*R*g+e()]})},rt=e=>{const t=[],s=Math.floor(x/2);for(let a=0;a<2;a++){const n=a*Math.PI;for(let o=0;o<s;o++){const h=o/(s-1),i=10*Math.PI*h,r=6,c=25*(h-.5);t.push([r*Math.cos(i+n)+e(),r*Math.sin(i+n)+e(),c+e()])}}for(;t.length<x;){const a=t.length%(2*s),n=t[a];t.push([n[0]+e()*.5,n[1]+e()*.5,n[2]+e()*.5])}return t},L=e=>{const t=e??Math.floor(Math.random()*3),s=T(.1),a=t===0?it(s):t===1?at(s):rt(s),n=[];if(t===0){for(let i=0;i<x-1;i++)n.push([i,i+1]);const o=3,h=Math.floor(x/o);for(let i=0;i<o;i++){const r=i*h;for(let c=0;c<h-20;c+=20)r+c+20<x&&n.push([r+c,r+c+20])}}else if(t===1){const h=Math.floor(x/27);for(let i=0;i<x;i++){const r=i%27,c=Math.floor(i/27);if(r<26&&n.push([i,i+1]),c<h-1)n.push([i,i+27]);else{const p=26-r;p<x&&n.push([i,p])}}}else{const o=Math.floor(x/2);for(let h=0;h<o-1;h++)n.push([h,h+1]);for(let h=o;h<2*o-1&&h<x-1;h++)n.push([h,h+1])}return I(a,n)},ht=()=>{const e=T(.1),t=2+Math.floor(Math.random()*2),s=3+Math.floor(Math.random()*3),a=8,n=3,o=Array.from({length:x},(i,r)=>{const c=r/x*2*Math.PI,M=(a+n*Math.cos(s*c))*Math.cos(t*c),p=(a+n*Math.cos(s*c))*Math.sin(t*c),y=n*Math.sin(s*c);return[M+e(),p+e(),y+e()]}),h=[];for(let i=0;i<x-1;i++)h.push([i,i+1]);return h.push([x-1,0]),I(o,h)},ct=()=>{const e=T(.15),t=3+Math.floor(Math.random()*3),s=Math.floor(Math.random()*(t+1)),a=.3+Math.random()*.3,n=10,o=[],h=Math.ceil(Math.sqrt(x));for(let r=0;r<x;r++){const c=r%h/(h-1),M=Math.floor(r/h)/(h-1),p=Math.PI*M,y=2*Math.PI*c,b=Math.sin(t*p)*Math.cos(s*y),R=n*(1+a*b),l=R*Math.sin(p)*Math.cos(y),f=R*Math.sin(p)*Math.sin(y),m=R*Math.cos(p);o.push([l+e(),f+e(),m+e()])}const i=[];for(let r=0;r<x;r++){const c=Math.floor(r/h);r%h<h-1&&i.push([r,r+1]),c<h-1&&r+h<x&&i.push([r,r+h])}return I(o,i)},lt=()=>{const e=T(.05),t=[];for(let l=0;l<16;l++)t.push([l&1?1:-1,l&2?1:-1,l&4?1:-1,l&8?1:-1]);const s=Math.random()*Math.PI/4,a=Math.random()*Math.PI/4,n=t.map(([l,f,m,d])=>{const u=l*Math.cos(s)-d*Math.sin(s),g=l*Math.sin(s)+d*Math.cos(s),w=f*Math.cos(a)-m*Math.sin(a),A=f*Math.sin(a)+m*Math.cos(a);return[u,w,A,g]}),o=3,h=6,i=n.map(([l,f,m,d])=>{const u=o-d;return[h*l/u,h*f/u,h*m/u]}),r=[];for(let l=0;l<16;l++)for(let f=l+1;f<16;f++){const m=l^f;(m&1?1:0)+(m&2?1:0)+(m&4?1:0)+(m&8?1:0)===1&&r.push([l,f])}const c=[],M=[];i.forEach(l=>{c.push([l[0]+e(),l[1]+e(),l[2]+e()])});const p=20;for(r.forEach(([l,f])=>{for(let m=1;m<p;m++){const d=m/p,u=pt(i[l],i[f],d);c.push([u[0]+e(),u[1]+e(),u[2]+e()])}});c.length<x;){const l=.3+.7*Math.random(),f=Math.floor(Math.random()*16),m=i[f];c.push([m[0]*l+e(),m[1]*l+e(),m[2]*l+e()])}const y=new Map;for(let l=0;l<16;l++)y.set(l,l);let b=16;const R=new Map;return r.forEach(([l,f])=>{const m=`${Math.min(l,f)}-${Math.max(l,f)}`,d=[];for(let u=0;u<p;u++)u>0&&u<p&&d.push(b++);R.set(m,d)}),r.forEach(([l,f])=>{const m=`${Math.min(l,f)}-${Math.max(l,f)}`,d=R.get(m)||[];if(d.length>0){M.push([l,d[0]]);for(let u=0;u<d.length-1;u++)M.push([d[u],d[u+1]]);M.push([d[d.length-1],f])}else M.push([l,f])}),I(c,M)},pt=(e,t,s)=>[e[0]*(1-s)+t[0]*s,e[1]*(1-s)+t[1]*s,e[2]*(1-s)+t[2]*s],ut=()=>{const e=T(.15),t=.8+Math.random()*.7,s=.15+Math.random()*.2,a=.2+Math.random()*.3,n=Array.from({length:x},(i,r)=>{const c=r%27/27*2*Math.PI,M=(Math.floor(r/27)/26-.5)*2,p=Math.sqrt(t*t+M/s*(M/s)),y=1+a*Math.sin(c*2);return[p*y*Math.cos(c)+e(),p*y*Math.sin(c)+e(),M*12+e()]}),o=[],h=Math.floor(x/27);for(let i=0;i<x;i++){const r=Math.floor(i/27);i%27<26?o.push([i,i+1]):o.push([i,i-26]),r<h-1&&o.push([i,i+27])}return I(n,o)},P={timing:{pauseMs:2e3,morphMs:6e3},line:{baseAlpha:{dark:.3,light:.25},distanceBoost:{dark:.3,light:.25},maxAlpha:{dark:.6,light:.5},thickness:.5},brownian:{amplitude:1.5,speed:.008,damping:.997},viewport:{padding:5,aspectRatio:.9}},v=729;var O=(e=>(e[e.Tensor=0]="Tensor",e[e.Morph1=1]="Morph1",e[e.Graph=2]="Graph",e[e.Morph2=3]="Morph2",e[e.Wormhole=4]="Wormhole",e[e.Morph3=5]="Morph3",e[e.TorusKnot=6]="TorusKnot",e[e.Spherical=7]="Spherical",e[e.Hypercube=8]="Hypercube",e))(O||{});const B=e=>e<.5?8*e*e*e*e:1-Math.pow(-2*e+2,4)/2,mt=(e,t,s)=>{const a=s?P.line.baseAlpha.dark:P.line.baseAlpha.light,n=s?P.line.distanceBoost.dark:P.line.distanceBoost.light,o=s?P.line.maxAlpha.dark:P.line.maxAlpha.light,h=Math.min(t/3,1);return Math.min((a+h*n)*e.strength,o)};function Mt(e,t,s,a=P.viewport.padding){const n=e.maxX-e.minX,o=e.maxY-e.minY,h=n*1.05,i=o*1.05,r=t-2*a,c=s-2*a,M=r/h,p=c/i,y=Math.min(M,p);return Math.max(y,.1)}class dt{layouts={};stateBounds={};unifiedScale=1;lines=[];machine;brownianOffsets;particleMapping=[];targetMapping=[];particleSizes=[];rotation={matrix:[[1,0,0],[0,1,0],[0,0,1]],current:{axis:[0,1,0],speed:1},target:{axis:[0,1,0],speed:1},future:{axis:[0,1,0],speed:1},transitionProgress:1,cycleCount:0};stateHistory=[];stateSequence=[];constructor(){this.generateLayouts(),this.brownianOffsets=U(v),this.particleMapping=Array.from({length:v},(a,n)=>n),this.targetMapping=Array.from({length:v},(a,n)=>n),this.particleSizes=this.generateParticleSizes();const t=this.getNextRandomState();this.stateHistory.push(t);const s=this.getNextRandomState();this.machine={state:t,next:s,t:0,phase:"pause",elapsed:0,startTime:0},this.initializeAllLines()}layoutGenerators={0:et,1:()=>L(0),2:ot,3:()=>L(1),4:ut,5:()=>L(2),6:ht,7:ct,8:lt};generateLayouts(){for(const t of Object.values(O))if(typeof t=="number"){const s=t;this.layouts[s]=this.layoutGenerators[s](),this.stateBounds[s]=this.layouts[s].bounds}}generateParticleSizes(){const t=[];for(let s=0;s<v;s++){let a=0,n=0;for(;a===0;)a=Math.random();for(;n===0;)n=Math.random();const o=Math.sqrt(-2*Math.log(a))*Math.cos(2*Math.PI*n),h=Math.max(.5,Math.min(3,1.5+o*.5));t.push(h)}return t}getNextRandomState(){const t=[0,1,2,3,4,5,6,7,8],s=this.stateHistory.slice(-2),a=t.filter(o=>!s.includes(o));if(a.length===0)return t[Math.floor(Math.random()*t.length)];const n=[];return a.forEach(o=>{o===8?n.push(o,o,o):n.push(o)}),n[Math.floor(Math.random()*n.length)]}updateUnifiedScale(t,s){const a=Object.values(O).filter(n=>typeof n=="number").map(n=>Mt(this.stateBounds[n],t,s,P.viewport.padding));this.unifiedScale=Math.min(...a)}initializeAllLines(){this.lines=this.layouts[this.machine.state].edges.map(([t,s])=>({a:t,b:s,strength:1}))}generateRandomMapping(){const t=Array.from({length:v},(s,a)=>a);for(let s=t.length-1;s>0;s--){const a=Math.floor(Math.random()*(s+1));[t[s],t[a]]=[t[a],t[s]]}this.targetMapping=t}updateRotation(){if(this.rotation.transitionProgress<1){const n=P.timing.pauseMs+P.timing.morphMs,o=this.machine.phase==="pause"?this.machine.elapsed:P.timing.pauseMs+this.machine.elapsed,h=(this.rotation.cycleCount*n+o)/(3*n);this.rotation.transitionProgress=Math.min(1,h);const i=B(this.rotation.transitionProgress);this.rotation.current.axis=this.slerpVec3(this.rotation.current.axis,this.rotation.target.axis,i),this.rotation.current.speed=this.rotation.current.speed*(1-i)+this.rotation.target.speed*i}const t=Math.PI/2e4,s=this.rotation.current.speed*t*16.67;Math.abs(s)>1e-4&&(this.rotation.matrix=this.multiplyRotationMatrix(this.rotation.matrix,this.createRotationMatrix(this.rotation.current.axis,s)))}slerpVec3(t,s,a){const n=t[0]*s[0]+t[1]*s[1]+t[2]*s[2];if(Math.abs(n)>.9999)return[...s];const o=Math.acos(Math.max(-1,Math.min(1,n))),h=Math.sin(o);if(Math.abs(h)<.001)return[...s];const i=Math.sin((1-a)*o)/h,r=Math.sin(a*o)/h,c=[i*t[0]+r*s[0],i*t[1]+r*s[1],i*t[2]+r*s[2]],M=Math.sqrt(c[0]**2+c[1]**2+c[2]**2);return M>0?[c[0]/M,c[1]/M,c[2]/M]:c}createRotationMatrix(t,s){const[a,n,o]=t,h=Math.cos(s),i=Math.sin(s),r=1-h;return[[h+a*a*r,a*n*r-o*i,a*o*r+n*i],[n*a*r+o*i,h+n*n*r,n*o*r-a*i],[o*a*r-n*i,o*n*r+a*i,h+o*o*r]]}multiplyRotationMatrix(t,s){const a=[[0,0,0],[0,0,0],[0,0,0]];for(let n=0;n<3;n++)for(let o=0;o<3;o++)for(let h=0;h<3;h++)a[n][o]+=t[n][h]*s[h][o];return a}update(t){if(this.machine.startTime===0&&(this.machine.startTime=t),this.machine.elapsed=t-this.machine.startTime,Z(this.brownianOffsets,P.brownian),this.updateRotation(),this.machine.phase==="pause")this.machine.elapsed>=P.timing.pauseMs&&(this.generateRandomMapping(),this.machine.phase="morph",this.machine.t=0,this.machine.startTime=t,this.machine.elapsed=0);else if(this.machine.t=Math.min(this.machine.elapsed/P.timing.morphMs,1),this.machine.t===1){this.particleMapping=[...this.targetMapping],this.machine.state=this.machine.next,this.stateHistory.push(this.machine.state),this.stateHistory.length>3&&this.stateHistory.shift(),this.machine.next=this.getNextRandomState(),this.updateRotationCycle();const s=[0,1,2,3,4,5,6,7,8],a=new Set([this.machine.state,this.machine.next,...this.stateHistory.slice(-2)]);s.filter(o=>!a.has(o)).forEach(o=>{this.layouts[o]=this.layoutGenerators[o](),this.stateBounds[o]=this.layouts[o].bounds}),this.machine.phase="pause",this.machine.startTime=t,this.machine.elapsed=0}this.updateLines()}updateRotationCycle(){this.rotation.cycleCount++,this.rotation.cycleCount>=3&&(this.rotation.target={...this.rotation.future},this.rotation.future=this.generateNewRotation(this.rotation.future.axis),this.rotation.cycleCount=0,this.rotation.transitionProgress=0)}generateNewRotation(t){const s=this.getPerpendicularAxis(t),a=Math.PI/4+Math.random()*Math.PI/2,n=this.createRotationMatrix(s,a),o=this.applyRotationToVector(t,n,!0),h=.9+Math.random()*.2;return{axis:o,speed:h}}getPerpendicularAxis(t){let s;Math.abs(t[2])<.9?s=[-t[1],t[0],0]:s=[0,-t[2],t[1]];const a=Math.sqrt(s[0]**2+s[1]**2+s[2]**2);return a>0?[s[0]/a,s[1]/a,s[2]/a]:s}applyRotationToVector(t,s,a=!1){const n=[0,0,0];for(let o=0;o<3;o++)for(let h=0;h<3;h++)n[o]+=s[o][h]*t[h];if(a){const o=Math.sqrt(n[0]**2+n[1]**2+n[2]**2);return o>0?[n[0]/o,n[1]/o,n[2]/o]:n}return n}updateLines(){if(this.machine.phase==="morph"){const s=this.machine.t,a=Math.max(0,1-s*2),n=Math.max(0,(s-.5)*2),o=this.layouts[this.machine.state].edges,h=this.layouts[this.machine.next].edges;this.lines=[...a>0?o.map(([i,r])=>({a:i,b:r,strength:a})):[],...n>0?h.map(([i,r])=>({a:i,b:r,strength:n})):[]]}else{const s=this.layouts[this.machine.state].edges;this.lines.length!==s.length?this.lines=s.map(([a,n])=>({a,b:n,strength:1})):this.lines.forEach(a=>a.strength=1)}}render(t,s,a){const n=K(),o=this.layouts[this.machine.state],h=this.layouts[this.machine.next],i=1,r=1,c=s/2,M=a/2,p=0,y=0,b=this.machine.phase==="morph",R=b?B(this.machine.t):0,l=this.unifiedScale*1;t.clearRect(0,0,s,a);const f=new Array(v);for(let m=0;m<v;m++){let d;if(b){const u=this.particleMapping[m],g=this.targetMapping[m],w=o.positions[u],A=h.positions[g];d=D(w,A,R)}else{const u=this.particleMapping[m];d=o.positions[u]}f[m]=this.applyRotationToVector(d,this.rotation.matrix)}this.lines.forEach(m=>{if(m.strength<.01)return;let d=-1,u=-1;if(b){const g=this.machine.t<.5?this.particleMapping:this.targetMapping;for(let w=0;w<v&&(g[w]===m.a&&(d=w),g[w]===m.b&&(u=w),!(d>=0&&u>=0));w++);}else for(let g=0;g<v&&(this.particleMapping[g]===m.a&&(d=g),this.particleMapping[g]===m.b&&(u=g),!(d>=0&&u>=0));g++);if(d>=0&&u>=0){const g=f[d],w=f[u],A=g[0]-w[0],E=g[1]-w[1],S=g[2]-w[2],j=Math.sqrt(A*A+E*E+S*S),Y=c+(g[0]+this.brownianOffsets.x[d]*P.brownian.amplitude-p)*l*i,X=M+(g[1]+this.brownianOffsets.y[d]*P.brownian.amplitude-y)*l*r,F=c+(w[0]+this.brownianOffsets.x[u]*P.brownian.amplitude-p)*l*i,G=M+(w[1]+this.brownianOffsets.y[u]*P.brownian.amplitude-y)*l*r;t.strokeStyle=n.lineColor,t.globalAlpha=mt(m,j,n.isDark),t.lineWidth=P.line.thickness,t.beginPath(),t.moveTo(Y,X),t.lineTo(F,G),t.stroke()}}),t.fillStyle=n.nodeColor,t.globalAlpha=1;for(let m=0;m<v;m++){const d=f[m],u=c+(d[0]+this.brownianOffsets.x[m]*P.brownian.amplitude-p)*l*i,g=M+(d[1]+this.brownianOffsets.y[m]*P.brownian.amplitude-y)*l*r,w=this.particleSizes[m];t.beginPath(),t.arc(u,g,w,0,Math.PI*2),t.fill()}}}function gt(){const e=q.useRef(null);return q.useEffect(()=>{const t=e.current;if(!t)return;const s=t.getContext("2d");if(!s)return;let a=!1,n=0,o=0;const h=Math.min(window.devicePixelRatio||1,2),i=new dt;let r=0;const c=()=>{let l=t.parentElement;for(;l&&l.clientWidth===0;)l=l.parentElement;return l},M=()=>{const f=c()?.clientWidth||0;if(f===0)return;n=f;const m=window.innerHeight,u=Math.max(m-200,400),g=Math.round(f*P.viewport.aspectRatio);o=Math.min(g,u),i.updateUnifiedScale(n,o),J(t,{width:n,height:o,dpr:h})},p=l=>{a||(i.update(l),i.render(s,n,o),r=requestAnimationFrame(p))};M();const y=new ResizeObserver(M);y.observe(t);const b=c();let R=null;return b&&(R=new ResizeObserver(M),R.observe(b)),r=requestAnimationFrame(p),()=>{a=!0,cancelAnimationFrame(r),y.disconnect(),R?.disconnect()}},[]),$.jsx("canvas",{ref:e,className:"block w-full","aria-hidden":"true"})}export{gt as default};
